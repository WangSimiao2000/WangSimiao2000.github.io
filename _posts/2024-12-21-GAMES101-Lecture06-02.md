---
title: GAMES101 第6讲 光栅化(深度缓冲)
date: 2024-12-21 21:50:00 +0800
categories: [笔记, GAMES101]
tags: [GAMES101, 计算机图形学]
math: true
---

## 深度缓冲

### 画家算法

**画家算法(Painter's Algorithm)**: 从后往前绘制, 后绘制的像素会覆盖先绘制的像素

例如下图中, 从后往前绘制, 会先绘制远处的山脉, 再绘制草地, 草地会覆盖部分山脉的像素, 然后绘制树木, 树木会覆盖部分草地的像素, 也会覆盖部分山脉的像素:

![画家算法](/assets/posts/GAMES101-Lecture06/23.png){:width="700px"}

但是画家算法有一个问题, 如果两个物体互相遮挡, 那么就会出现问题, 如下图所示:

![画家算法问题](/assets/posts/GAMES101-Lecture06/24.png){:width="400px"}

### 深度缓冲(Z-Buffer)

**深度缓冲(Z-Buffer)**: 为每个像素存储一个深度值, 当绘制一个像素时, 先检查该像素的深度值, 如果新像素的深度值小于深度缓冲中的深度值, 那么就更新深度缓冲中的深度值, 并绘制新像素
- 在渲染过程中, 除了最终得出的结果的图象, 还会生成一个**深度图**, 用于记录每个像素所看到的几何物体的**最浅**的深度信息, 这个图象就是**深度缓冲**, 也叫**深度图**
- 最终图象叫做**Frame Buffer**, 深度信息的图象叫做**Depth Buffer**, 两者**同时生成**

图形学常常假设相机在原点, 观察方向为 $-z$ 轴, 但是为了我们方便计算, 我们假设 $z$ 的值始终为正值, 即 $z$ 越大, 越远离相机, $z$ 越小, 越靠近相机

![深度缓冲的示例](/assets/posts/GAMES101-Lecture06/25.png){:width="700px"}

深度缓冲的算法如下:
1. 初始化深度缓冲, 将所有像素的深度值设为无穷大(无穷远)
2. 将所有三角形的像素绘制到深度缓冲中, 每次绘制一个像素时, 检查该像素的深度值
3. 如果新像素的深度值小于深度缓冲中的深度值, 那么就更新深度缓冲中的深度值, 并绘制新像素

![深度缓冲的算法](/assets/posts/GAMES101-Lecture06/26.png){:width="700px"}

算法复杂度:
- 假设每个三角形都会覆盖相同的常数个像素
- 时间复杂度: $O(n)$